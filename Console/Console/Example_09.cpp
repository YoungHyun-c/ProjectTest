#include <iostream>


#pragma region 포인터
/* 
포인터는 주소를 저장하는 변수이다.
메모리 공간을 가리키는 녀석이다.
그 말인 즉슨, 모든 데이터는 어느 특정 공간에 저장되어있다.

pointer
-> 포인터는 주소를 저장한다.
-> 모든 데이터는 메모리상에 특정한 공간에 저장되어있음.
-> 기존의 우리가 알고있는 변수는 데이터를 저장하지만, 포인터는 메모리 공간의 주소를 저장한다.
-> 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야한다.
 ㄴ 변수이름앞에 & 연산자를 붙이면 해당 변수의 시작 주소를 리턴(반환)한다.
-> 또한 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면, * 연산자를 사용한다.
& : 특정한 데이터의 메모리 상의 주소값을 알 수 있다.
* : &연산자가 어떤 데이터의 주소값을 얻어내는 연산자라면,
반면에 *연산자는 주소값에서 해당 주소값에 대응되는 데이터를 가져온다.

포인터변수는 주소만 저장하는 녀석인데. 왜 타입이 있을까?
int Num;
pointer(라는 타입이 있다고 가정할때)*p;
p = &Num;
-> 시작주소만 알기 때문에 자료형 타입을 알아야지 데이터를 얼마만큼 읽어들여야 될지 알 수 있기 때문이다.
 ex) int면 시작 주소에서 +4 바이트씩 떨어진 곳에 값이 들어있는 것을 알 수 있다.


---------
const 절대로 값이 바뀌지 않는, 값이 바뀌지 않을 것 같은 것에 일단 붙이기.


*/
#pragma endregion



int main()
{
	int* p; // 포인터 변수 p 선언.

	int a = 2;
	p = &a; // 변수 a의 주소를 저장.
	std::cout << "P의 값(a의 주소값) : " << p << std::endl;
	std::cout << std::endl;
	std::cout << "*p의 값(a의 값) : " << *p << std::endl;
	*p = 100;
	std::cout << "p의 값 변경 후 :" << *p << std::endl;


	int num;
	const int* pa = &num;
	int b;
	// const int* 이란
	/*
		const int형 변수를 가르킨다는것이 아니라.
		int형 변수를 가리키는데 그 값을 절대로 바꾸지 말라는 뜻.
		즉, pa는 어떤 int형 변수를 가리키고 있고, const가
		붙어있기 때문에 pa가 가리키는 변수의 값은 절대로,
		바뀌면 안된다는 뜻이다.
	*/
	//*pa = 3; // Error
	//pa = &b; // Ok

	{
		int a;
		int b;

		// const int* -> 주소에 있는 값을 상수화 시키겠다.
		// int* const -> 주소를 상수화 시키겠다.
		int* const pa = &a;
		*pa = 3; // Ok
		pa = &b; // Error
		// ㄴ pa의 주소 값이 바뀌면 안된다는 것.
		// 위에서는 a의 주소를 저장.
		// pa는 절대적으로 바뀌면 안되지만, b의 주소를 담으라고 했기 때문에 Error
	}

	return 0;
}